%author:   Philipp Ulbl
%created:  07.01.2020

addpath('~/KiLCA_interface/')
addpath('~/BALANCE/')

runpath = '/temp/ulbl_p/BALANCE_2017/Test/';
mpath = pwd();

%##########################################################################
% PREPROCESS PARAMETERS
%##########################################################################

FLAG_FORCE_KISSLINGER = false;      %forces recalculation of field.dat
FLAG_FORCE_FOURIER = false;         %forces recalculation of amn.dat
FLAG_FORCE_PROFILES = false;        %forces recalculation of profiles

FLAG_USE_NEVILLE = false;            %use neville polynomials instead of splines
NEVILLE_DEG = 9;                    %degree of neville polynomials

%##########################################################################
% SHOT PARAMETERS
%##########################################################################

shot = 33120;
time = 5500;

m = 3:11;
n = 2 .* ones(size(m));

%dynamical filepaths from shot and time

%experimental input
%gfile  = ['/temp/ulbl_p/AUG/SHOTS/',num2str(shot),'/g',num2str(shot),'.',num2str(time),'_EQH'];
gfile = '/proj/plasma/RMP/DATA2017/33133/3.0s/g33133.3000_ed4';
filehead = ['/temp/ulbl_p/AUG/SHOTS/',num2str(shot),'/',num2str(shot),'.',num2str(time)];
cfile  = [filehead,'_coil.dat'];
neprof = [filehead,'_ne_IDA_rho_pol.dat'];
Teprof = [filehead,'_Te_IDA_rho_pol.dat'];
Tiprof = [filehead,'_Ti_PED_ulbl_rho_pol.dat'];
vtprof = [filehead,'_vt_PED_ulbl_rho_pol.dat'];
kprof = '/temp/heyn/BALANCE_2017/33120_5500/Neo2_kcoef/kprof.33120_5500';

%location of field.dat
%pfile = ['/temp/ulbl_p/MESH3D/',num2str(shot),'/field.dat']; %will be calculated if not present
pfile = '/itp/MooseFS/kasilov/MESH3D_31135odd/field.dat';
fluxdatapath = ['/temp/ulbl_p/FLUXDATA/',num2str(shot),'/']; %will be calculated if not present

%##########################################################################
% AUG PARAMETERS
%##########################################################################

%these values are arbitrary but must be larger than r_end
%r_end is the maximum radius in equil_r_q_psi.dat which will be calculated
%below ( = real position of separatrix)
r_sep = 67;             %position of separatrix
r_ant = 70;             %position of antenna
r_idw = 80;             %position of ideal wall

r_sta = 3;              %minimum radius in calculations of KiLCA
r_min = 0.1;            %minimum radius to take from exp data

r_max = r_ant;          %maximum radius in balance
r_max_prof = r_max+1;   %maximum radius for profiles (> r_ant)

rb_cut_out = 67.5;      %
re_cut_out = 68;        %

%location of convexfile for AUG machine
convexfile = '/proj/plasma/RMP/DATA/ASDEX/convexwall.dat';
softpath = '/proj/plasma/soft/';

%##########################################################################
% CONSTANTS
%##########################################################################

c = 29979245800.0;      % sol in cgs
kB = 1.3807e-16;        % Boltzmann constant
eVK = 1.1604e4;         % eV -> deg(K)
echarge = 4.8031e-10;   % statcoulomb

%##########################################################################
% CHECK FILES
%##########################################################################

if(exist(gfile, 'file') ~= 2)
    error(['gfile not found in: ', gfile]);
end
if(exist(cfile, 'file') ~= 2)
    error(['coil file not found in: ', cfile]);
end
if(exist(convexfile, 'file') ~= 2)
    error(['convexfile not found in: ', convexfile]);
end

if(exist(neprof, 'file') ~= 2)
    error(['neprof not found in: ', neprof]);
end
if(exist(Teprof, 'file') ~= 2)
    error(['Teprof not found in: ', Teprof]);
end
if(exist(Tiprof, 'file') ~= 2)
    error(['Tiprof not found in: ', Tiprof]);
end
if(exist(vtprof, 'file') ~= 2)
    error(['vtprof not found in: ', vtprof]);
end

%##########################################################################
% COIL -> KISSLINGER
%##########################################################################

%check if pfile exists
if(exist(pfile, 'file') ~= 2 || FLAG_FORCE_KISSLINGER == true)
    
    coilpath = '../COIL/';

    %COIL CONVERTER
    curfile = [coilpath, 'cur_asd_', num2str(shot), '.dd'];
    coil = AUG_coil(cfile);
    coil.read();
    coil.export2Kisslinger(curfile, true);

    cd(coilpath)
    %create symbolic link to pfile path
    [ppath, ~, ~] = fileparts(pfile);
    ppath = [ppath, '/'];
    system(['ln -sfT ', ppath, ' ', 'MESH3D']);
    %create symbolic link to pfile
    system(['ln -sf ', curfile, ' ', 'cur_asd.dd']);
    %KISSLINGER.INP - could be set here
    
    %run kisslinger to create field.dat. ~1.5h run time
    disp(['Start of Kisslinger at ', datestr(datetime)])
    [~, res] = system('./kisslinger_asdex.x');

    %log file
    fid = fopen(['kisslinger_', datestr(datetime), '.log'], 'w');
    fprintf(fid, '%s\n', res);
    fclose(fid);
    
    disp(['Finished Kisslinger at ', datestr(datetime)])
    cd(mpath)
end

%##########################################################################
% FOURIER
%##########################################################################

%FOURIERMODES
amnpath = [fluxdatapath, 'amn.dat'];
btorrbigpath = [fluxdatapath, 'btor_rbig.dat'];
equilrqpsipath = [fluxdatapath, 'equil_r_q_psi.dat'];

%init divB0 class
fdb0 = field_divB0(gfile, pfile, convexfile, '');

%check if amn exists. if not run with ipert=1 (use coil file)
if(exist(amnpath, 'file') ~= 2 || FLAG_FORCE_FOURIER == true)
    fdb0.ipert = 1;
    run_fourier = true;
%check if btorrbig and equilrqpsi exists. if not run with ipert=0 (only equi)
elseif(exist(btorrbigpath, 'file') ~= 2 || exist(equilrqpsipath, 'file') ~= 2)
    fdb0.ipert = 0;
    run_fourier = true;
%else no run of fourier
else
    run_fourier = false;
end

if(run_fourier==true)
    fourierpath = '../FOURIER/';
    
    fdb0.write('blueprints/', fourierpath);
    cd(fourierpath)
    %FOURIERMODES.INP
    disp(['Start of Fouriermodes at ', datestr(datetime)])
    [~, res] = system('./fouriermodes.x');

    %log file
    fid = fopen(['fouriermodes_', datestr(datetime), '.log'], 'w');
    fprintf(fid, '%s\n', res);
    fclose(fid);

    disp(['Finished Fouriermodes at ', datestr(datetime)])
    
    %move output to fluxdatapath
    outfiles = {'amn.dat','btor_rbig.dat','equil_r_q_psi.dat','axis.dat',''};
    for k=1:numel(outfiles)
    	system(['mv -f ' outfiles{k}, ' ', fluxdatapath]);
    end
    
    cd(mpath)
end

%output of fouriermodes: rbig, btor
raw = load(btorrbigpath);
b_tor = raw(1);
r_big = raw(2);

%output of fouriermodes: equil r q psi
%read equil file
raw = equil_read(equilrqpsipath);
%extract r, q, psi
r = raw(:,1);                           % equivalent radius
q = raw(:,2);                           % safety factor q
psi_pol_norm = raw(:,3)./raw(end,3);    % normalized poloidal flux

%##########################################################################
% PROFILE MAGIC
%##########################################################################

profpath = [runpath, 'profiles/'];
%create path if not existent
system(['mkdir -p ', profpath]);
 
if(exist([profpath, 'q.dat'], 'file')  ~= 2 || exist([profpath, 'n.dat'], 'file') ~= 2 || ...
   exist([profpath, 'Te.dat'], 'file') ~= 2 || exist([profpath, 'Ti.dat'], 'file') ~= 2 || ...
   exist([profpath, 'Vz.dat'], 'file') ~= 2 || exist([profpath, 'Vth.dat'], 'file') ~= 2 || ...
   exist([profpath, 'Er.dat'], 'file') ~= 2 || FLAG_FORCE_PROFILES == true)
    recalc_prof = true;
else
    recalc_prof = false;
end

if(recalc_prof == true)
    %electron temperature Te
    Te = profile_magician('Te', Teprof, profpath, 1);
    Te.read(true);
    Te_inf = Te.y_in(end); %last value from IDA is fine
    Te.process(r, psi_pol_norm, r_min, r_max_prof, Te_inf);
    Te.write();

    %radius for all output profiles
    r_out = Te.r_out;

    %density n
    ne = profile_magician('n', neprof, profpath, 1e-6);
    ne.read(true);
    ne_inf = ne.y_in(end); %last value from IDA is fine
    ne.process(r, psi_pol_norm, r_min, r_max_prof, ne_inf);
    ne.write();

    %ion temperature Ti
    Ti = profile_magician('Ti', Tiprof, profpath, 1);
    Ti.read(true);
    Ti_inf = Te.y_in(end) .* Ti.y_in(1) / Te.y_in(1); %last value of Te weighted by Ti/te ratio
    Ti.process(r, psi_pol_norm, r_min, r_max_prof, Ti_inf);
    Ti.write();

    %toroidal velocity vt
    vz = profile_magician('Vz', vtprof, profpath, r_big);
    vz.read(true);
    vz.d = 0.3; %wider cut region
    vt_inf = vz.y_in(end); %last value
    vz.process(r, psi_pol_norm, r_min, r_max_prof, vt_inf);
    vz.write();

    %q - magic: 
    %1) calc B out of q; J out of B
    %2) do profile magic on J
    %3) recalc B out of J; recalc q out of B
    r_ode = r;
    psi_ode = psi_pol_norm;
    q_ode = -q;

    Te_ode = interp1(Te.r_out, Te.y_out, r_ode, 'spline');
    Ti_ode = interp1(Ti.r_out, Ti.y_out, r_ode, 'spline');
    ne_ode = interp1(ne.r_out, ne.y_out, r_ode, 'spline');

    %total pressure
    p_ode = ne_ode .* (Te_ode + Ti_ode) .* kB .* eVK;
    %g-factor
    g_ode = 1 + (r_ode ./ -q_ode ./ r_big).^2;
    %radial derivative of pressure
    if(FLAG_USE_NEVILLE == true)
        dp_ode = eval_neville_polynom_for_array(length(r_ode), r_ode, p_ode, NEVILLE_DEG, r_ode, 1, 1);
    else %numerical gradient
        dp_ode = gradient(p_ode, r_ode);
    end

    %anonymous functions for ode solver
    fq  = @(x) interp1(r_ode, q_ode, x, 'spline');
    fg  = @(x) interp1(r_ode, g_ode, x, 'spline');
    fdp = @(x) interp1(r_ode, dp_ode, x, 'spline');
    %solve ode for fields (=u)
    odefun = @(x, y) -2.0 * x .* y ./ fq(x).^2 ./ fg(x) / r_big^2 - 8.0 * pi * fdp(x);
    odeopt = odeset ('RelTol', 1e-12);
    disp(['Start of ODE113 at ', datestr(datetime)])
    [r_ode, u_ode] = ode113(odefun, r_ode, b_tor^2 * g_ode(1), odeopt);
    disp(['Finished ODE113 at ', datestr(datetime)])
    %get field components out for u
    Bz_ode = sign(b_tor) * sqrt(u_ode ./ g_ode);
    Bth_ode = r_ode .* Bz_ode ./ q_ode / r_big;

    %radial derivatives of field components
    if(FLAG_USE_NEVILLE == true)
        dBth_ode = eval_neville_polynom_for_array(length(r_ode), r_ode, Bth_ode, NEVILLE_DEG, r_ode, 1, 1);
        dBz_ode = eval_neville_polynom_for_array(length(r_ode), r_ode, Bz_ode, NEVILLE_DEG, r_ode, 1, 1);
    else %spline (num gradient pretty bad for B)
        Bth_spline = spline(r_ode, Bth_ode);
        dBth_spline = splineder(Bth_spline);
        dBth_ode = ppval(dBth_spline, r_ode);

        Bz_spline = spline(r_ode, Bz_ode);
        dBz_spline = splineder(Bz_spline);
        dBz_ode = ppval(dBz_spline, r_ode);
    end
    %currents
    Jth_ode = - c / 4 / pi * dBz_ode;
    Jz_ode = c / 4 / pi * (Bth_ode ./ r_ode + dBth_ode);

    %poloidal current Jth
    Jth = profile_magician('Jth', '', '', 1);
    Jth.psi_in = psi_ode;
    Jth.y_in = Jth_ode;
    Jth.d = 0.2;
    Jth.dr_cut = -0.3;
    Jth_inf = 0; %no current in vacuum
    Jth.process(r, psi_ode, 0, r_max_prof, Jth_inf, 'ee');

    %toroidal current Jz
    Jz = profile_magician('Jz', '', '', 1);
    Jz.psi_in = psi_ode;
    Jz.y_in = Jz_ode;
    Jz.d = 0.2;
    Jz.dr_cut = -0.3;
    Jz_inf = 0; %no current in vacuum
    Jz.process(r, psi_ode, 0, r_max_prof, Jz_inf, 'ee');

    %magnetic field
    Bth_out = 4 * pi / c * cumtrapz(Jz.r_out, Jz.r_out .* Jz.y_out) ./ Jz.r_out ...
                + Bth_ode(1) .* r_ode(1) ./ Jz.r_out; %initial conditions
    Bz_out = -4 * pi / c * cumtrapz(Jth.r_out, Jth.y_out) + Bz_ode(1);

    %safety factor
    q_out = r_out / r_big .* Bz_out ./ Bth_out;
    qp = profile_magician('q', '', profpath, 1);
    qp.r_out = Jz.r_out;
    qp.y_out = q_out;
    qp.write();

    %##########################################################################
    % NEO-2
    %##########################################################################

    %first: diamagnetic velocities
    B_out = sqrt(Bz_out.^2 + Bth_out.^2);
    p_out = ne.y_out .* (Te.y_out + Ti.y_out) .* kB .* eVK;
    dp_out = gradient(p_out, r_out);
    %ion temperature gradient
    if(FLAG_USE_NEVILLE == true)
        dTi_out = eval_neville_polynom_for_array(length(Ti.r_out), Ti.r_out, Ti.y_out, NEVILLE_DEG, Ti.r_out, 1, 1) .* kB .* eVK;
    else
        dTi_out = gradient(Ti.y_out, Ti.r_out) .* kB .* eVK;
    end
    %ion diamag velocities
    %vdi = c .* Bz_out .* dp_out ./ (echarge .* ne.y_out .* B_out.^2); %ordinary
    vdihat = c .* Bz_out .* dTi_out ./ (echarge .* B_out.^2); %kinetic

    %load k profile - output of NEO-2
    raw = load(kprof);
    rneo = raw(:, 1);
    kneo = raw(:, 2);
    kneo = kneo(~isnan(rneo));
    rneo = rneo(~isnan(rneo));

    %extend k profile to rmax
    rneo(end+1) = r_max;
    kneo(end+1) = 0.5.*kneo(end);
    kneo_interp = interp1(rneo, kneo, r, 'pchip');

    %profile magic on k
    k = profile_magician('k', '', '', 1);
    k.psi_in = psi_pol_norm;
    k.y_in = kneo_interp;
    k_inf = 0.5 .* kneo(end);
    k.process(r, psi_pol_norm, r_min, r_max_prof, k_inf);

    %poloidal velocity out of k
    vth = profile_magician('Vth', '', profpath, 1);
    vth.r_out = r_out;
    vth.y_out = k.y_out .* vdihat;
    vth.write();

    %radial electric field
    Er_out = 1 ./ (echarge .* ne.y_out) .* dp_out - k.y_out .* dTi_out / echarge;
    %add toroidal rotation
    Er_out = Er_out - r_out .* vz.y_out .* B_out ./ (r_big .* c .* qp.y_out);
    Er = profile_magician('Er', '', profpath, 1);
    Er.r_out = r_out;
    Er.y_out = Er_out;
    Er.write();
end

%##########################################################################
% PREPARE KiLCA
%##########################################################################

%FLRE, VACUUM USING KiLCA CLASS
nmodes = 1;
rad = [r_sta, r_sep, r_ant, r_idw];
bound = {'center', 'interface', 'antenna', 'idealwall'};
med = {'vacuum', 'vacuum', 'vacuum'};

kil_vac = KiLCA_interface(runpath, 'vacuum');
kil_vac.BLUE_PATH = '~/KiLCA_interface/blueprints/';
kil_vac.PROF_PATH = profpath;
kil_vac.set_background(r_big, r_sep);
kil_vac.background.Btor = b_tor;
kil_vac.set_antenna(r_ant, nmodes);
med{1} = kil_vac.run_type;
kil_vac.set_zones(rad, bound, med);

kil_flre = KiLCA_interface(runpath, 'flre');
kil_flre.BLUE_PATH = '~/KiLCA_interface/blueprints/';
kil_flre.PROF_PATH = profpath;
kil_flre.set_background(r_big, r_sep);
kil_flre.background.Btor = b_tor;
kil_flre.set_antenna(r_ant, nmodes);
med{1} = kil_flre.run_type;
kil_flre.set_zones(rad, bound, med);

kil_vac.antenna.I0 = 1e13;
kil_vac.antenna.flab(1) = 1;
kil_vac.zones{3}.vacuum.sigma(1) = 1.3e16;

kil_flre.antenna.I0 = 1e13;
kil_flre.antenna.flab(1) = 1;
kil_flre.zones{3}.vacuum.sigma(1) = 1.3e16;

%##########################################################################
% RUN BALANCE WITH MATLAB CLASS
%##########################################################################

%FIELD DIVB0
fluxdatapath = '/proj/plasma/RMP/DATA2017/33120/5.5s/PREPROCESS_EQB/';
fdb0 = field_divB0(gfile, pfile, convexfile, fluxdatapath);
fdb0.write('blueprints/', runpath);
system(['ln -sfT ', softpath, ' ', runpath, 'soft']);

%BALANCE OPTIONS
balopt = balanceoptions(kil_flre.pathofrun, kil_vac.pathofrun);
balopt.Btor = b_tor;
balopt.Rtor = r_big;
balopt.rmin = r_sta;
balopt.rmax = r_ant;
balopt.rsep = r_sep;
balopt.rb_cut_out = rb_cut_out;
balopt.re_cut_out = re_cut_out;

%BALANCE CODE
bal = balancecode(runpath, softpath);
bal.setOptions(balopt);
bal.setFactors(0);
bal.setModes(m, n);
bal.setKiLCA(kil_flre, kil_vac);
bal.write();
bal.run();
bal.loadOutput();

%##########################################################################
% POSTPROCESS
%##########################################################################

%load output of Balance
figure('units', 'normalized', 'outerposition', [0, 0, 1, 1]); 
hold on
for i = 1:numel(m)
    f5k = bal.outputs{i}.fort5000;
    f5k.plot('de22', 'D_e22', 'DisplayName', ['m=', num2str(m(i)), ', n=', num2str(n(i))]);
end
plot(xlim, 1e4 .* [1, 1], '-k', 'DisplayName', 'Da')
hold off
legend()
% ylim([0 2e4])



% %load output of KiLCA vac + postprocessing
% kil_vac.modes.set(m, n);
% kil_vac.antenna.nmod = numel(m);
% kil_vac.runExternal();
% kil_vac.loadOutput();
% kil_vac.post();
% 
% %load output of KiLCA flre + postprocessing
% kil_flre.modes.set(m, n);
% kil_flre.antenna.nmod = numel(m);
% kil_flre.runExternal();
% kil_flre.loadOutput();
% kil_flre.post();
% 
% %KiLCA multimode processing
% %kil_flre.multimode.plotQuant('Br', 'B / G', 'Abs');
% %kil_flre.multimode.plotVsVac(kil_vac, 'Br', 'B / G', 'Abs');
% kil_flre.multimode.plotShielding(kil_vac);
% 













