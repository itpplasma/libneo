module spline1d_many_cuda_fortran
    use, intrinsic :: iso_fortran_env, only: dp => real64
    use cudafor, only: dim3, cudaDeviceSynchronize, threadIdx, blockIdx, blockDim
    implicit none
    private

    public :: spline1d_many_cuda_fortran_setup
    public :: spline1d_many_cuda_fortran_teardown
    public :: spline1d_many_cuda_fortran_eval_device
    public :: spline1d_many_cuda_fortran_get_y

    logical :: is_setup = .false.

    integer :: cached_order = -1
    integer :: cached_num_points = -1
    integer :: cached_num_quantities = -1
    integer :: cached_npts = -1
    integer :: cached_periodic_int = 0
    real(dp) :: cached_x_min = 0.0d0
    real(dp) :: cached_h_step = 0.0d0

    real(dp), device, allocatable :: coeff_dev(:)
    real(dp), device, allocatable :: x_dev(:)
    real(dp), device, allocatable :: y_dev(:)

contains

    attributes(global) subroutine spline1d_many_kernel(order, num_points, &
                                                       num_quantities, &
                                                       periodic_int, x_min, h_step, &
                                                       coeff, x, y, npts)
        integer, value, intent(in) :: order
        integer, value, intent(in) :: num_points
        integer, value, intent(in) :: num_quantities
        integer, value, intent(in) :: periodic_int
        integer, value, intent(in) :: npts
        real(dp), value, intent(in) :: x_min
        real(dp), value, intent(in) :: h_step
        real(dp), device, intent(in) :: coeff(*)
        real(dp), device, intent(in) :: x(*)
        real(dp), device, intent(inout) :: y(*)

        integer :: ipt, idx, iq, k_power, base
        real(dp) :: period, xj, x_norm, x_local
        real(dp) :: t, w
        integer :: stride_k, stride_i
        integer :: k_wrap

        ipt = (blockIdx%x - 1)*blockDim%x + threadIdx%x
        if (ipt > npts) return

        period = h_step*real(num_points - 1, dp)
        if (periodic_int == 1) then
            t = x(ipt) - x_min
            k_wrap = int(t/period)
            w = t - real(k_wrap, dp)*period
            if (w < 0.0d0) w = w + period
            xj = w + x_min
        else
            xj = x(ipt)
        end if

        x_norm = (xj - x_min)/h_step
        idx = int(x_norm)
        if (idx < 0) idx = 0
        if (idx > num_points - 2) idx = num_points - 2
        x_local = (x_norm - real(idx, dp))*h_step

        stride_k = num_quantities
        stride_i = num_quantities*(order + 1)
        base = idx*stride_i

        do iq = 1, num_quantities
            y((ipt - 1)*num_quantities + iq) = coeff(base + (order*stride_k) + iq)
        end do
        do k_power = order - 1, 0, -1
            do iq = 1, num_quantities
                y((ipt - 1)*num_quantities + iq) = coeff(base + &
                                                         (k_power*stride_k) + iq) + &
                                                   x_local*y((ipt - &
                                                              1)*num_quantities + iq)
            end do
        end do
    end subroutine spline1d_many_kernel

    subroutine spline1d_many_cuda_fortran_setup(order, num_points, num_quantities, &
                                                periodic, &
                                                x_min, h_step, coeff, x)
        integer, intent(in) :: order
        integer, intent(in) :: num_points
        integer, intent(in) :: num_quantities
        logical, intent(in) :: periodic
        real(dp), intent(in) :: x_min
        real(dp), intent(in) :: h_step
        real(dp), intent(in) :: coeff(num_quantities, 0:order, num_points)
        real(dp), intent(in) :: x(:)

        integer :: ncoeff

        if (order < 0) error stop
        if (num_points < 2) error stop
        if (num_quantities < 1) error stop

        cached_order = order
        cached_num_points = num_points
        cached_num_quantities = num_quantities
        cached_npts = size(x)
        if (periodic) then
            cached_periodic_int = 1
        else
            cached_periodic_int = 0
        end if
        cached_x_min = x_min
        cached_h_step = h_step

        ncoeff = num_quantities*(order + 1)*num_points
        allocate (coeff_dev(ncoeff))
        coeff_dev = reshape(coeff, [ncoeff])

        allocate (x_dev(size(x)))
        x_dev = x

        allocate (y_dev(num_quantities*size(x)))
        y_dev = 0.0d0

        is_setup = .true.
    end subroutine spline1d_many_cuda_fortran_setup

    subroutine spline1d_many_cuda_fortran_teardown()
        if (.not. is_setup) return
        if (allocated(y_dev)) deallocate (y_dev)
        if (allocated(x_dev)) deallocate (x_dev)
        if (allocated(coeff_dev)) deallocate (coeff_dev)
        is_setup = .false.
    end subroutine spline1d_many_cuda_fortran_teardown

    subroutine spline1d_many_cuda_fortran_eval_device()
        type(dim3) :: grid, block
        integer :: ierr
        integer :: npts_local, block_x, grid_x

        if (.not. is_setup) error stop

        npts_local = cached_npts
        block_x = 256
        grid_x = (npts_local + block_x - 1)/block_x
        block = dim3(block_x, 1, 1)
        grid = dim3(grid_x, 1, 1)

        call spline1d_many_kernel<<<grid, block>>>( &
            cached_order, cached_num_points, cached_num_quantities, &
            cached_periodic_int, &
            cached_x_min, cached_h_step, coeff_dev, x_dev, y_dev, npts_local &
            )
        ierr = cudaDeviceSynchronize()
        if (ierr /= 0) error stop
    end subroutine spline1d_many_cuda_fortran_eval_device

    subroutine spline1d_many_cuda_fortran_get_y(y)
        real(dp), intent(out) :: y(:)

        if (.not. is_setup) error stop
        if (size(y) /= size(y_dev)) error stop
        y = y_dev
    end subroutine spline1d_many_cuda_fortran_get_y

end module spline1d_many_cuda_fortran
