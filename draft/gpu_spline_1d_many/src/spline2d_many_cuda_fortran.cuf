module spline2d_many_cuda_fortran
    use, intrinsic :: iso_fortran_env, only: dp => real64
    use cudafor, only: dim3, cudaDeviceSynchronize, threadIdx, blockIdx, blockDim
    implicit none
    private

    public :: spline2d_many_cuda_fortran_setup
    public :: spline2d_many_cuda_fortran_teardown
    public :: spline2d_many_cuda_fortran_eval_device
    public :: spline2d_many_cuda_fortran_get_y

    logical :: is_setup = .false.

    integer :: cached_order(2) = [-1, -1]
    integer :: cached_num_points(2) = [-1, -1]
    integer :: cached_num_quantities = -1
    integer :: cached_npts = -1
    integer :: cached_periodic_int(2) = [0, 0]
    real(dp) :: cached_x_min(2) = [0.0d0, 0.0d0]
    real(dp) :: cached_h_step(2) = [0.0d0, 0.0d0]

    real(dp), device, allocatable :: coeff_dev(:)
    real(dp), device, allocatable :: x_dev(:)
    real(dp), device, allocatable :: y_dev(:)

contains

    attributes(global) subroutine spline2d_many_kernel(order1, order2, n1, n2, nq, periodic1, &
                                                       periodic2, x_min1, x_min2, h1, h2, &
                                                       coeff, x, y, npts)
        integer, value, intent(in) :: order1, order2, n1, n2, nq, periodic1, periodic2, npts
        real(dp), value, intent(in) :: x_min1, x_min2, h1, h2
        real(dp), device, intent(in) :: coeff(*)
        real(dp), device, intent(in) :: x(*)
        real(dp), device, intent(inout) :: y(*)

        integer :: ipt, i1, i2, iq, k1, k2, base
        integer :: stride_k1, stride_k2, stride_i1, stride_i2
        real(dp) :: period1, period2, xj1, xj2, x_norm1, x_norm2, x_local1, x_local2
        real(dp) :: t, w, v, yq

        ipt = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        if (ipt > npts) return

        period1 = h1 * real(n1 - 1, dp)
        period2 = h2 * real(n2 - 1, dp)

        xj1 = x(2 * ipt - 1)
        xj2 = x(2 * ipt)
        if (periodic1 == 1) then
            t = xj1 - x_min1
            w = t - floor(t / period1) * period1
            xj1 = w + x_min1
        end if
        if (periodic2 == 1) then
            t = xj2 - x_min2
            w = t - floor(t / period2) * period2
            xj2 = w + x_min2
        end if

        x_norm1 = (xj1 - x_min1) / h1
        x_norm2 = (xj2 - x_min2) / h2
        i1 = int(x_norm1)
        i2 = int(x_norm2)
        if (i1 < 0) i1 = 0
        if (i1 > n1 - 2) i1 = n1 - 2
        if (i2 < 0) i2 = 0
        if (i2 > n2 - 2) i2 = n2 - 2
        x_local1 = (x_norm1 - real(i1, dp)) * h1
        x_local2 = (x_norm2 - real(i2, dp)) * h2

        stride_k1 = nq
        stride_k2 = nq * (order1 + 1)
        stride_i1 = nq * (order1 + 1) * (order2 + 1)
        stride_i2 = stride_i1 * n1

        base = i1 * stride_i1 + i2 * stride_i2

        do iq = 1, nq
            v = coeff(base + (order2 * stride_k2) + (order1 * stride_k1) + iq)
            do k1 = order1 - 1, 0, -1
                v = coeff(base + (order2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * v
            end do
            yq = v
            do k2 = order2 - 1, 0, -1
                v = coeff(base + (k2 * stride_k2) + (order1 * stride_k1) + iq)
                do k1 = order1 - 1, 0, -1
                    v = coeff(base + (k2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * v
                end do
                yq = v + x_local2 * yq
            end do
            y((ipt - 1) * nq + iq) = yq
        end do
    end subroutine spline2d_many_kernel

    subroutine spline2d_many_cuda_fortran_setup(order, num_points, nq, periodic, x_min, h_step, &
                                                coeff, x)
        integer, intent(in) :: order(2)
        integer, intent(in) :: num_points(2)
        integer, intent(in) :: nq
        logical, intent(in) :: periodic(2)
        real(dp), intent(in) :: x_min(2)
        real(dp), intent(in) :: h_step(2)
        real(dp), intent(in) :: coeff(nq, 0:order(1), 0:order(2), num_points(1), num_points(2))
        real(dp), intent(in) :: x(:, :)

        integer :: ncoeff
        real(dp), allocatable :: coeff_flat(:)

        cached_order = order
        cached_num_points = num_points
        cached_num_quantities = nq
        cached_npts = size(x, 2)
        cached_x_min = x_min
        cached_h_step = h_step
        if (periodic(1)) then
            cached_periodic_int(1) = 1
        else
            cached_periodic_int(1) = 0
        end if
        if (periodic(2)) then
            cached_periodic_int(2) = 1
        else
            cached_periodic_int(2) = 0
        end if

        ncoeff = nq * (order(1) + 1) * (order(2) + 1) * num_points(1) * num_points(2)
        allocate (coeff_flat(ncoeff))
        coeff_flat = reshape(coeff, [ncoeff])
        allocate (coeff_dev(ncoeff))
        coeff_dev = coeff_flat

        allocate (x_dev(2 * size(x, 2)))
        x_dev = reshape(x, [2 * size(x, 2)])

        allocate (y_dev(nq * size(x, 2)))
        y_dev = 0.0d0

        is_setup = .true.
    end subroutine spline2d_many_cuda_fortran_setup

    subroutine spline2d_many_cuda_fortran_teardown()
        if (.not. is_setup) return
        if (allocated(y_dev)) deallocate (y_dev)
        if (allocated(x_dev)) deallocate (x_dev)
        if (allocated(coeff_dev)) deallocate (coeff_dev)
        is_setup = .false.
    end subroutine spline2d_many_cuda_fortran_teardown

    subroutine spline2d_many_cuda_fortran_eval_device()
        type(dim3) :: grid, block
        integer :: ierr, block_x, grid_x

        if (.not. is_setup) error stop

        block_x = 256
        grid_x = (cached_npts + block_x - 1) / block_x
        block = dim3(block_x, 1, 1)
        grid = dim3(grid_x, 1, 1)

        call spline2d_many_kernel<<<grid, block>>>(cached_order(1), cached_order(2), &
            cached_num_points(1), cached_num_points(2), cached_num_quantities, &
            cached_periodic_int(1), cached_periodic_int(2), cached_x_min(1), cached_x_min(2), &
            cached_h_step(1), cached_h_step(2), coeff_dev, x_dev, y_dev, cached_npts)
        ierr = cudaDeviceSynchronize()
        if (ierr /= 0) error stop
    end subroutine spline2d_many_cuda_fortran_eval_device

    subroutine spline2d_many_cuda_fortran_get_y(y)
        real(dp), intent(out) :: y(:)

        if (.not. is_setup) error stop
        if (size(y) /= size(y_dev)) error stop
        y = y_dev
    end subroutine spline2d_many_cuda_fortran_get_y

end module spline2d_many_cuda_fortran
