module spline3d_many_cuda_fortran
    use, intrinsic :: iso_fortran_env, only: dp => real64
    use cudafor, only: dim3, cudaDeviceSynchronize, threadIdx, blockIdx, blockDim
    implicit none
    private

    public :: spline3d_many_cuda_fortran_setup
    public :: spline3d_many_cuda_fortran_teardown
    public :: spline3d_many_cuda_fortran_eval_device
    public :: spline3d_many_cuda_fortran_get_y

    logical :: is_setup = .false.

    integer :: cached_order(3) = [-1, -1, -1]
    integer :: cached_num_points(3) = [-1, -1, -1]
    integer :: cached_num_quantities = -1
    integer :: cached_npts = -1
    integer :: cached_periodic_int(3) = [0, 0, 0]
    real(dp) :: cached_x_min(3) = [0.0d0, 0.0d0, 0.0d0]
    real(dp) :: cached_h_step(3) = [0.0d0, 0.0d0, 0.0d0]

    real(dp), device, allocatable :: coeff_dev(:)
    real(dp), device, allocatable :: x_dev(:)
    real(dp), device, allocatable :: y_dev(:)

contains

    attributes(global) subroutine spline3d_many_kernel(order1, order2, order3, n1, n2, n3, nq, &
                                                       p1, p2, p3, x_min1, x_min2, x_min3, &
                                                       h1, h2, h3, coeff, x, y, npts)
        integer, value, intent(in) :: order1, order2, order3, n1, n2, n3, nq, p1, p2, p3, npts
        real(dp), value, intent(in) :: x_min1, x_min2, x_min3, h1, h2, h3
        real(dp), device, intent(in) :: coeff(*)
        real(dp), device, intent(in) :: x(*)
        real(dp), device, intent(inout) :: y(*)

        integer :: ipt, i1, i2, i3, iq, k1, k2, k3, base
        integer :: stride_k1, stride_k2, stride_k3, stride_i1, stride_i2, stride_i3
        real(dp) :: period1, period2, period3
        real(dp) :: xj1, xj2, xj3, x_norm1, x_norm2, x_norm3
        real(dp) :: x_local1, x_local2, x_local3
        real(dp) :: t, w, v, w2, yq
        integer :: k_wrap

        ipt = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        if (ipt > npts) return

        period1 = h1 * real(n1 - 1, dp)
        period2 = h2 * real(n2 - 1, dp)
        period3 = h3 * real(n3 - 1, dp)

        xj1 = x(3 * ipt - 2)
        xj2 = x(3 * ipt - 1)
        xj3 = x(3 * ipt)

        if (p1 == 1) then
            t = xj1 - x_min1
            k_wrap = int(t / period1)
            w = t - real(k_wrap, dp) * period1
            if (w < 0.0d0) w = w + period1
            xj1 = w + x_min1
        end if
        if (p2 == 1) then
            t = xj2 - x_min2
            k_wrap = int(t / period2)
            w = t - real(k_wrap, dp) * period2
            if (w < 0.0d0) w = w + period2
            xj2 = w + x_min2
        end if
        if (p3 == 1) then
            t = xj3 - x_min3
            k_wrap = int(t / period3)
            w = t - real(k_wrap, dp) * period3
            if (w < 0.0d0) w = w + period3
            xj3 = w + x_min3
        end if

        x_norm1 = (xj1 - x_min1) / h1
        x_norm2 = (xj2 - x_min2) / h2
        x_norm3 = (xj3 - x_min3) / h3
        i1 = int(x_norm1)
        i2 = int(x_norm2)
        i3 = int(x_norm3)
        if (i1 < 0) i1 = 0
        if (i1 > n1 - 2) i1 = n1 - 2
        if (i2 < 0) i2 = 0
        if (i2 > n2 - 2) i2 = n2 - 2
        if (i3 < 0) i3 = 0
        if (i3 > n3 - 2) i3 = n3 - 2
        x_local1 = (x_norm1 - real(i1, dp)) * h1
        x_local2 = (x_norm2 - real(i2, dp)) * h2
        x_local3 = (x_norm3 - real(i3, dp)) * h3

        stride_k1 = nq
        stride_k2 = nq * (order1 + 1)
        stride_k3 = nq * (order1 + 1) * (order2 + 1)
        stride_i1 = nq * (order1 + 1) * (order2 + 1) * (order3 + 1)
        stride_i2 = stride_i1 * n1
        stride_i3 = stride_i2 * n2
        base = i1 * stride_i1 + i2 * stride_i2 + i3 * stride_i3

        do iq = 1, nq
            w2 = coeff(base + (order3 * stride_k3) + (order2 * stride_k2) + (order1 * stride_k1) + iq)
            do k1 = order1 - 1, 0, -1
                w2 = coeff(base + (order3 * stride_k3) + (order2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * w2
            end do
            do k2 = order2 - 1, 0, -1
                v = coeff(base + (order3 * stride_k3) + (k2 * stride_k2) + (order1 * stride_k1) + iq)
                do k1 = order1 - 1, 0, -1
                    v = coeff(base + (order3 * stride_k3) + (k2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * v
                end do
                w2 = v + x_local2 * w2
            end do
            yq = w2
            do k3 = order3 - 1, 0, -1
                w2 = coeff(base + (k3 * stride_k3) + (order2 * stride_k2) + (order1 * stride_k1) + iq)
                do k1 = order1 - 1, 0, -1
                    w2 = coeff(base + (k3 * stride_k3) + (order2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * w2
                end do
                do k2 = order2 - 1, 0, -1
                    v = coeff(base + (k3 * stride_k3) + (k2 * stride_k2) + (order1 * stride_k1) + iq)
                    do k1 = order1 - 1, 0, -1
                        v = coeff(base + (k3 * stride_k3) + (k2 * stride_k2) + (k1 * stride_k1) + iq) + x_local1 * v
                    end do
                    w2 = v + x_local2 * w2
                end do
                yq = w2 + x_local3 * yq
            end do
            y((ipt - 1) * nq + iq) = yq
        end do
    end subroutine spline3d_many_kernel

    subroutine spline3d_many_cuda_fortran_setup(order, num_points, nq, periodic, x_min, h_step, &
                                                coeff, x)
        integer, intent(in) :: order(3)
        integer, intent(in) :: num_points(3)
        integer, intent(in) :: nq
        logical, intent(in) :: periodic(3)
        real(dp), intent(in) :: x_min(3)
        real(dp), intent(in) :: h_step(3)
        real(dp), intent(in) :: coeff(nq, 0:order(1), 0:order(2), 0:order(3), &
                                      num_points(1), num_points(2), num_points(3))
        real(dp), intent(in) :: x(:, :)

        integer :: ncoeff
        real(dp), allocatable :: coeff_flat(:)

        cached_order = order
        cached_num_points = num_points
        cached_num_quantities = nq
        cached_npts = size(x, 2)
        cached_x_min = x_min
        cached_h_step = h_step
        cached_periodic_int = 0
        if (periodic(1)) cached_periodic_int(1) = 1
        if (periodic(2)) cached_periodic_int(2) = 1
        if (periodic(3)) cached_periodic_int(3) = 1

        ncoeff = nq * (order(1) + 1) * (order(2) + 1) * (order(3) + 1) * &
            num_points(1) * num_points(2) * num_points(3)
        allocate (coeff_flat(ncoeff))
        coeff_flat = reshape(coeff, [ncoeff])
        allocate (coeff_dev(ncoeff))
        coeff_dev = coeff_flat

        allocate (x_dev(3 * size(x, 2)))
        x_dev = reshape(x, [3 * size(x, 2)])

        allocate (y_dev(nq * size(x, 2)))
        y_dev = 0.0d0

        is_setup = .true.
    end subroutine spline3d_many_cuda_fortran_setup

    subroutine spline3d_many_cuda_fortran_teardown()
        if (.not. is_setup) return
        if (allocated(y_dev)) deallocate (y_dev)
        if (allocated(x_dev)) deallocate (x_dev)
        if (allocated(coeff_dev)) deallocate (coeff_dev)
        is_setup = .false.
    end subroutine spline3d_many_cuda_fortran_teardown

    subroutine spline3d_many_cuda_fortran_eval_device()
        type(dim3) :: grid, block
        integer :: ierr, block_x, grid_x

        if (.not. is_setup) error stop

        block_x = 256
        grid_x = (cached_npts + block_x - 1) / block_x
        block = dim3(block_x, 1, 1)
        grid = dim3(grid_x, 1, 1)

        call spline3d_many_kernel<<<grid, block>>>(cached_order(1), cached_order(2), cached_order(3), &
            cached_num_points(1), cached_num_points(2), cached_num_points(3), cached_num_quantities, &
            cached_periodic_int(1), cached_periodic_int(2), cached_periodic_int(3), &
            cached_x_min(1), cached_x_min(2), cached_x_min(3), cached_h_step(1), cached_h_step(2), &
            cached_h_step(3), coeff_dev, x_dev, y_dev, cached_npts)
        ierr = cudaDeviceSynchronize()
        if (ierr /= 0) error stop
    end subroutine spline3d_many_cuda_fortran_eval_device

    subroutine spline3d_many_cuda_fortran_get_y(y)
        real(dp), intent(out) :: y(:)

        if (.not. is_setup) error stop
        if (size(y) /= size(y_dev)) error stop
        y = y_dev
    end subroutine spline3d_many_cuda_fortran_get_y

end module spline3d_many_cuda_fortran

